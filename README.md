<div align="center">
    <img src="Images/LOGO-FT-UNP-2.png" alt="Logo">
    <img src="https://user-images.githubusercontent.com/73097560/115834477-dbab4500-a447-11eb-908a-139a6edaec5c.gif">
    <img src="Images/praklogo.png" alt="prakLogo">
</div>

<div align="center">
    <table>
    <tr>
    <td>
    <b><pre>
    <h3>
    Nama                : Ridho Hamdani Putra
    NIM                 : 23343052
    Program Studi       : Informatika
    Kode Kelas          : INF1.62.2014
    Dosen Pengampu      : Randi Proska Sandra, M.Sc
    </h3>
    </pre></b>
    </td>
    </tr>
    </table>
</div>
    
</div>
<img src="https://user-images.githubusercontent.com/73097560/115834477-dbab4500-a447-11eb-908a-139a6edaec5c.gif">
<img src="Images/Jobsheet01.png" alt="Jobsheet 01">
<p align="justify">
  Pada jobsheet 1 ini berisi tentang apa itu struktur data. Struktur data adalah cara penyimpanan, penyusunan dan pengaturan data di dalam media penyimpanan komputer sehingga data tersebut dapat digunakan secara efisien. Sedangkan data adalah representasi dari fakta dunia nyata. Konstanta digunakan untuk menyatakan nilai tetap sedangkan variable digunakan untuk menyatakan nilai yang dapat berubah.
</p>
<p align="justify">
  Selanjutnya juga ada 4 istilah data yaitu : </p>
  
<ol>
 <li>Signed integer</li>
 <li>Unsigned interger</li>
 <li>Floating point</li>
 <li>Decimal</li>
</ol>

<p>Struktur data terbagi dalam 2 yaitu : </p> 
<ol>
 <li>Struktur data sederhana, misalnya arrray dan record</li>
 <li>Struktur data majemuk, yang terdiri dari</li>
 <ol>
   <li>linier : Stack, Queue, sertaList dan Multilist</li>
   <li>Non linier : pohon biner dan graph</li>
</ol>
</ol>

<p align="justify">
   Dengan menggunakan struktur data yang tepat proses pemrograman akan menghasilkan algoritma yang lebih jelas dan tepat.
</p>

<img src="https://user-images.githubusercontent.com/73097560/115834477-dbab4500-a447-11eb-908a-139a6edaec5c.gif">
<img src="Images/Jobsheet02.png" alt="Jobsheet 02">
<p align="justify">
  Pada jobsheet 2 ini kita mempelajari tentang bagaimana konsep penggunaan array, pointer, structure dan ADT di dalam program. Yang mana pada semester 1 kemarin kita telah mempelajari bagaimana konsep array, pointer, struct dan sedikit tentang ADT.
</p>

<p align="justify">
  <b>Array</b> adalah suatu kumpulan nilai yang bertipe data sama. Setiap data di dalam array dapat kita akses dengan menggunakan indeks dan elemen array dapat diakses langsung secara acak. Dimensi array dinyatakan dalam bentuk baris dan kolom seperti matriks. <b>Pointer</b> adalah sebuah variabel yang berisi alamat memori sebagai nilainya, berbeda dengan variabel biasa yang isinya berupa sebuah nilai tertentu. <b>Pointer</b> di deklarasikan dengan  menggunakan tanda asterik atau bintang (*) didepan nama variabel.
</p>
<p align="justify">
  Selanjutnya ada <b>Structure</b>, <b>struct</b> ini adalah kumpulan variabel yang memiliki tipe tipe data yang berbeda, mirip seperti array tetapi array hanya bisa menggabungkan tipe data yang sama saja. Untuk menamai struct kita dapat menggunakan kata kunci struct untuk dapat mengaksesnya nanti, ada 2 tipe operator yang digunakan untuk mengakses struct yaitu : <li>'.' - member operator</li> <li>'-> - operator yang digunakan untuk pointer</li>
</p>

<p align="justify">
 Terakhir ada <b>ADT (Abstract Data Type)</b>, <b>ADT</b> adalah koleksi data dan operasi yang dapat digunakan untuk memanipulasi data tertentu yang telah didefinisikan oleh pemrogram. Dalam membuat tipe data bentukan ini di dalam bahasa C kita tidak boleh menggunakan nama yang sudah ada di dalam keyword bahasa C, seperti int, float, char dll. Kita dapat membuatnya dengan format :<br><br> typedef-(nama tipe data lama)-(nama tipe data baru).
</p>

<p align="justify">
  
<img src="https://user-images.githubusercontent.com/73097560/115834477-dbab4500-a447-11eb-908a-139a6edaec5c.gif">
<img src="Images/Jobsheet03.png" alt="Jobsheet 03">
<p align="justify">
  Pada jobsheet 3 ini kita mempelajadi tentang <b>Single Linked List</b>, struktur data <b>Link List</b>, operasi <b>Link List</b>, dan implementasi <b>Simpul/Node</b>.
</p>

<p align="justify">
  <b>Simpul/Node</b> adalah sebuah struct yang didalamnya berisi alamat dan kumpulan data dengan format seperti berikut :<br><br> struct node <br> { <br> int data; <br> struct node *next; <br> } <br><br> <b>Alokasi Memory</b> penggunaan alokasi memori ini menyediakan kita fasilitas untuk membuat ukuran buffer dan array secara dinamik. karena kelemahan di dalam tipe data array ini yaitu sifatnya yang statis. Artinya ketika kita mendeklarasikan array maka data yang kita deklarasikan disimpan dalam memori yang harus dalam konsisi terurut. 
 <ul>
  <li>perintah sizeof()</li>
  <li>perintah malloc()</li>
 </ul>
</p>

<p align="justify">
  Selanjutnya ada <b>Single Link List</b> yang merupakan sebuah data yang berupa simpul atau node beralamat yang saling terhubung. Setiap simpul data menyimpan data yang berisi tipe tipe data lainnya. Logikanya seperti pencarian harta karun yang mana pada setiap titik kita mendapatkan clue untuk ke rute selanjutnya mulai dari clue pertama sampai kita menemukan harta karun tersebut. biasanya data pertama di dalam linked list ini dinamai dengan <b>Head</b> dan data terkahir dinamai dengan <b>Tail</b>.
</p>

<img src="https://user-images.githubusercontent.com/73097560/115834477-dbab4500-a447-11eb-908a-139a6edaec5c.gif">
<img src="Images/Jobsheet04.png" alt="Jobsheet 04">
<p align="justify">
  Pada jobsheet 4 ini kita mempelajari tentang konsep dan penggunaan penyimpana <b>Doubly Linked List</b>, yang pada job sebelumnya kita mempelajari single linked list dan ini adalah lanjutan nya yang mana data di dalam nya saling terkait secara dua arah. 
</p>

<p align="justify">
  Kelebihan Doubly Linked List dibandingkan denganSingle Link List :
 <ul>
  <li>DLL bisa berjalan dalam 2 arah kedepan dan kebelakang</li>
  <li>Operasi penghapusan lebih efisien dan simple dengan menggunakan pointer yang menujuk ke simpul yang akan dihapus</li>
  <li>Dapat melakukan proses insert yang lebih efisien</li>
 </ul>
</p>
<p align="justify">
  Kelemahan Doubly Link List dibandingkan dengan Single Link List :
 <ul>
  <li>Setiap siimpul DLL membutuhkan ruang memory tambahan untuk pointer to pointer</li>
  <li>Setiap operasi yang dilakukan harus mencantumkan pointer simpul sebelumnya</li>
 </ul>
</p>

<p align="justify">
  Jenis Insertion() :
 <ul>
  <li>Penambahan simpul di depan</li>
  <li>Penambahan setelah simpul</li>
  <li>Di simpul paling akhir</li>
  <li>Penambahan sebelum simpul tertentu</li>
 </ul>
</p>

<img src="https://user-images.githubusercontent.com/73097560/115834477-dbab4500-a447-11eb-908a-139a6edaec5c.gif">
<img src="Images/Jobsheet05.png" alt="Jobsheet 05">
<p align="justify">
  Pada jobsheet 5 ini kita mempelajari tentang bagaimana konsep <b>Double Linked List dan Cricular Lingked List</b>.
</p>

<p align="justify">
  <b>Double Linked List</b> adalah list elemen yang dihubungkan dengan dua pointer dalam satu node. Struktur ini menyebabkan list melintas baik kedepan ataupun kebelakang. Elemen pada double linked list terdiri dari tiga bagian, disamping data (info) dan pointer next, setiap elemen dilengkapi dengan pointer prev dan next . Untuk menunjukkan head dari double linked list ini maka pointer prev dari elemn pertama menunjukkan nilai NULL. Untuk menunjukkan tail dari double linked list, maka pointer next dari elemen terakhir menunjuk nilai NULL.
</p>

<p align="justify">
  <b>Circular Linked List</b> adalah bentuk lain dari linked list yang memberikan fleksibelitas. Circular linked list ini dapat berupa single linked list ataupun double linked list. Pada circular ini pointer next dari elemn terakhir tidak menujukkan nilai NULL tetapi nenunjuk pada elemen pertama.
</p>

<p align="justify">
  
</p>

<img src="https://user-images.githubusercontent.com/73097560/115834477-dbab4500-a447-11eb-908a-139a6edaec5c.gif">
<img src="Images/Jobsheet06.png" alt="Jobsheet 06">

<p align="justify">
  Pada jobsheet 6 ini kita mempelajari tentang konsep <b>Stack</b>. <b>Stack</b> adalah sebuah kumpulan data yang mana letaknya berada di atas data yang lain.<b>Stuck</b> adalah struktur data yang menggunakan konsep LIFO (Last In First Out). Dalam proses komputasi, untuk meletakkan sebuah elem pada bagian atas stack, disebut dengan <b>push</b>, dan untuk memindahkan data dari tempat yang atas, disebut <b>pop</b>.
</p>
<p>
  
</p>
 <b>Stack dengan Array</b>, bentuk penyajian stack bisa menggunakan tipe data array, tetapi kurang tepat karena banyaknya elemen dalam array adalah statis, sedangkan dalam stack banyaknya elemen didalamnya dinamis. Pada suatu saat, ukuran stack akan sama dengan array, bila terus menambhkan data maka akan terjadi overflow. Maka perlu ditambahkan data untuk mencatat posisi ujung stack, yaitu <b>Single Stack</b> dan <b>Double Stack</b>.
<p align="justify">
  
</p>
 <b>Operasi pada Stack</b> 
 <ul>
  <li><b>Push</b> digunakan untuk menambahkan elemen atau data baru pada stack. Elemen baru tersbut akan menjadi elemen paling atas di dalam stack.</li>
  <li><b>Pop</b> digunakan untuk menghapus elen yang berada paling atas dari stack</li>
  <li><b>Peek</b> digunakan untuk mengecek elemen atau data paling atas tanpa menghapusnya</li>
  <li><b>isFull</b> digunakan untuk memeriksa apakah kondisi stack sudah penuh</li>
  <li><b>isEmpty</b> digunakan untuk memeriksa apakah stack masih dalam kondisi kosong</li>
  <li><b>Clear</b> digunakan untuk mengosongkan stack</li>
 </ul>
<p align="justify">

<img src="https://user-images.githubusercontent.com/73097560/115834477-dbab4500-a447-11eb-908a-139a6edaec5c.gif">
<img src="Images/Jobsheet07.png" alt="Jobsheet 07">
<p align="justify">
  Pada jobsheet 7 ini kita mempelajari tentang bagaimana konsep stack dan operasi pada queue. Queue adalah struktur data linier yang menerapkan prinsip operasi dimana elemen data yang masuk pertama akan keluar lebih dulu. Prinsip ini dikenal dengan istilah FIFO (First In, First Out). Persamaan antara stack dan queue adalah keduanya dapat diimplementasikan menggunakan struktur data linked list atau array.
</p>
 
<p align="justify">
  Spesifikasi Queue :
 <ul>
  <li>Enqueue: digunakan untuk menambah elemen di akhir queue</li>
  <li>Dequeue: digunakan untuk menghapus elemen awal queue</li>
  <li>IsEmpty: digunakan untuk mengecek apakah queue kosong</li>
  <li>IsFull: digunakan untuk mengecek apakah queue penuh</li>
  <li>Peek: digunakan untuk mengintip nilai queue</li>
 </ul>
</p>

<p align="justify">
  Cara kerja queue :
 <ul>
  <li>Dua pointer yang disebut FRONT dan REAR digunakan untuk melacak elemen pertama dan 
terakhir dalam antrian.</li>
  <li>Saat menginisialisasi antrian, kami menetapkan nilai FRONT dan REAR ke -1.</li>
  <li>Pada enqueing elemen, kita meningkatkan nilai indeks REAR dan menempatkan elemen baru di 
posisi yang ditunjuk oleh REAR.</li>
  <li>Pada dequeueing suatu elemen, kita mengembalikan nilai yang ditunjuk oleh FRONT dan 
meningkatkan indeks FRONT.</li>
  <li>Sebelum enqueing, kami memeriksa apakah antrian sudah penuh.</li>
  <li>Sebelum dequeuing, kami memeriksa apakah antrian sudah kosong.</li>
  <li>Saat membuat elemen pertama, kami menetapkan nilai FRONT ke 0.</li>
  <li>Saat mendekor elemen terakhir, kita mereset nilai FRONT dan REAR ke -1.</li>
 </ul>
</p>

<img src="https://user-images.githubusercontent.com/73097560/115834477-dbab4500-a447-11eb-908a-139a6edaec5c.gif">
<img src="Images/Jobsheet08.png" alt="Jobsheet 08">
<p align="justify">
  
</p>

<p align="justify">
  <b>Sorting (Pengurutan)</b> : merupakan proses pengurutan data yang sebelumnya disusun secara acak sehingga tersusun secara teratur menurut aturan tertentu. Teknik Sorting yang umum digunakan : buble sort, insertion sort, selection sort, quicksort, mergesort, heapsort, dan binary sort
</p>
 
<p align="justify">
  <b>Buble Sort</b> : metode/algoritma pengurutan dengan dengan cara melakukan penukaran data dengan tepat disebelahnya secara terus menerus sampai bisa dipastikan dalam satu iterasi tertentu tidak ada lagi perubahan. Jika tidak ada perubahan berarti data sudah terurut. Disebut pengurutan gelembung karena masing-masing kunci akan dengan lambat menggelembung ke posisinya yang tepat.
</p>

<p align="justify">
  <b>Insertion Sort</b> : merupakan sebuah teknik pengurutan dengan cara membandingkan dan mengurutkan dua data pertama pada array, kemudian membandingkan data para array berikutnya apakah sudah berada di tempat semestinya. Algoritma insertion sort seperti proses pengurutan kartu yang berada di tangan kita.
</p>

<img src="https://user-images.githubusercontent.com/73097560/115834477-dbab4500-a447-11eb-908a-139a6edaec5c.gif">
<img src="Images/Jobsheet09.png" alt="Jobsheet 09">
<p align="justify">
  <b>Selection Sort </b> : merupakan sebuah algoritma yang digunakan untuk mencari dna memilih element/data terkecil dalam sebuah list yang belum tersusun dalam setiap iterasi dan menempatkan elemen terkecil di urutan paling depan dari urutan list data.
</p>
<p>Cara kerja Slecetion Sort: </p>
<p align="justify">
  <ol type="1">
  <li>Tentukan elemen pertama dari urutan menjadi elemen terkecil masukkan sebagai elemen “minimum”.</li>
  <li>Bandingkan mnimum dengan urutan elemen kedua. Jika elemen kedua lebih kcil dibandingkan minimum, jadikan elemen kedua sebagai minimum. Bandingkan kembali minimum dengan elemen ketiga. Lakukan secara terus menerus samapai dengan elemen yang terakhir.  </li>
  <li>Setelah setiap perulangan, minimum ditempatkan di paling depan urutan list data </li>
  <li>pada setiap pengulangan, indeksasi (pemberian alamat) dimulai dari elemen pertama dari list. langkah 1-3 dilakukan berulang kali samapi keseluruhan elemen digantikan pada posisi yang 
terurut. </li>
</ol>
</p>
<p align="justify">
  <b>Merge Sort </b> : merupakan pengurutan gabungan terus-menerus memotong daftar menjadi beberapa subdaftar hingga masing-masing hanya memiliki satu item, lalu menggabungkan subdaftar tersebut ke dalam daftar yang diurutkan.
<p>Divide-and-conquer memecahkan sub-masalah secara rekursif; setiap submasalah harus lebih kecil dari masalah aslinya, dan masing-masing harus mempunyai kasus dasar. Algoritme bagi-dan-taklukkan memiliki tiga bagian::
<ol type="1">
  <li>Bagilah masalah menjadi beberapa bagian kecil dari masalah yang sama</li>
  <li>Taklukkan submasalah dengan menyelesaikannya secara rekursif. Selesaikan submasalah sebagai kasus dasar jika submasalah tersebut cukup kecil.</li>
  <li>Untuk menemukan solusi dari masalah awal, gabungkan solusi dari submasalah.</li>
</ol>
</p>

<img src="https://user-images.githubusercontent.com/73097560/115834477-dbab4500-a447-11eb-908a-139a6edaec5c.gif">
<img src="Images/Jobsheet10.png" alt="Jobsheet 10">
<p align="justify">
  <b>Shell Sort</b> : merupakan sebuah algoritma dengan pengurutan elemen pertama memiliki jarak interval dengan elemen yang akan dibandingkan. Pada prinsipnya sama dengan Insertion sort pada pokok bahasan sebelumnya.</p>
<p>Dalam pengurutan Shell Sort, elemen/data diurutkan dengan interval yang terukur. Jarak interval diantara elemen semakin lama semakin mengecil berdasarkan berapa kali pengulangan pengurutan 
 dilakukan.
</p>

<p>Cara kerja Shell Sort: </p>

<p align="justify">
  <ol type="1">
  <li>Urutkan array yang ada  </li>
  <li>Pada fase pertama, jika besar array N=8 maka jarak interval elemen menggunakan rumus N/2 = 4, akan dibandingkan dan ditukar jika belum sesuai urutan. </li>
  <li>Pada pengulangan kedua rumus formula interval yang digunakan N/4 = 8/4 = 2, Elemen ke 2 dan ke 4 dibandingkan sesuai rumus interval = 2, elemen ke 0 dan 2 juga dibandingkan. </li>
  <li>Proses yang sama berlaku untuk elemen yang tersisa. </li>
  <li>Pada akhirnya samapai pada fase akhir di saat interval N/8  = 8/8 = 1, elemen dengan interval 1 diurutkan </li>
</ol>
</p>

<p align="justify">
  <b>Quick Sort</b> : Algoritma ini mengambil sebuah elemen sebagai pivot dan memisahkan array yang ada disekitar pivot.</p>
<p>Proses utama dalam quickSort adalah partisi() . Target dari partisi adalah untuk menempatkan pivot (elemen apa pun dapat dipilih menjadi pivot) pada posisi yang benar dalam susunan yang diurutkan dan meletakkan semua elemen yang lebih kecil di sebelah kiri pivot, dan semua elemen yang lebih besar di sebelah kanan pivot. Partisi dilakukan secara rekursif pada setiap sisi pivot setelah pivot ditempatkan pada posisi yang benar dan akhirnya mengurutkan array.
</p>

<img src="https://user-images.githubusercontent.com/73097560/115834477-dbab4500-a447-11eb-908a-139a6edaec5c.gif">
<img src="Images/Jobsheet11.png" alt="Jobsheet 11">

<p align="justify">
  Ada dua macam teknik pencarian yaitu pencarian sekuensial <b>linear search</b> dan pencarian biner 
<b>binary search</b>.  Perbedaan dari dua teknik ini terletak pada keadaan data.  Pencarian sekuensial 
digunakan apabila data dalam keadaan acak atau tidak terurut.  Sebaliknya, pencarian biner digunakan 
pada data yang sudah dalam keadaan urut.
</p>

<p align="justify">
Algoritma pencarian berurutan dapat dituliskan sebagai berikut: 
<ul>
 <li> 1. i ← 0 </li>
 <li> 2. ketemu ← false </li>
 <li> 3. Selama (tidak ketemu) dan (i <= N) kerjakan baris 4 </li>
 <li> 4. Jika (Data[i] = x) maka ketemu ← true, jika tidak i ← i + 1  </li>
 <li> 5. Jika (ketemu) maka i adalah indeks dari data yang dicari, jika tidak data tidak ditemukan </li>
</ul>
</p>

<p align="justify">
 Algoritma binary search:  
<ul>
 <li> 1. Data diambil dari posisi 1 sampai posisi akhir N </li>
 <li> 2. Kemudian cari posisi data tengah dengan rumus: (posisi awal + posisi akhir) / 2 </li>
 <li> 3. Kemudian data yang dicari dibandingkan dengan data yang di tengah, apakah sama atau lebih  kecil, atau lebih besar. </li>
 <li> 4. Jika lebih besar, maka proses pencarian dicari dengan posisi awal adalah posisi tengah + 1 </li>
 <li> 5. Jika lebih kecil, maka proses pencarian dicari dengan posisi akhir adalah posisi tengah – 1 </li>
 <li> 6. Jika data sama, berarti ketemu. </li>
</ul>
</p>

<img src="https://user-images.githubusercontent.com/73097560/115834477-dbab4500-a447-11eb-908a-139a6edaec5c.gif">
<img src="Images/Jobsheet12.png" alt="Jobsheet 12">

<p align="justify">
  Traverse atau Melintasi sebuah pohon data/tree artinya mengunjungi semua simpul yang ada pada pohon tersebut. Ada beberapa hal yang dapat dilakukan contoh jika ingin menambah nilai semua data pada pohon tersebut atau mencari nilai tertinggi diantaranya. Untuk operasi-operasi tersebut, harus dilakukan mengunjungi setiap simpul dari pohon data.
</p>

<p align="justify">
  terdapat 3 cara melintasi tree :
<br>1. Inorder Traversal 
<br>langkah-langkahnya : 
  <li>Kunjungi semua nodes/simpul di sebelah kiri subtree. </li>
  <li>Kemudian kunjungi root node/simpul paling atas </li>
  <li>Kunjungi semua simpul yang ada di kanan subtree </li>

 <br>2. Preorder Traversal 
 <br>langkah-langkahnya : 
  <li>Visit root node  </li>
  <li>Visit all the nodes in the left subtree </li>
  <li>Visit all the nodes in the right subtree </li>

 <br>3. Postorder Traversal 
 <br>langkah-langkahnya : 
  <li>Visit all the nodes in the left subtree  </li>
  <li>Visit all the nodes in the right subtree </li>
  <li>Visit the root node </li>
</p>

<img src="https://user-images.githubusercontent.com/73097560/115834477-dbab4500-a447-11eb-908a-139a6edaec5c.gif">
<img src="Images/Jobsheet13.png" alt="Jobsheet 13">

<p align="justify">
<b>Depth First Search/Traversal</b><br>
Traversal berarti mengunjungi semua node dari suatu graph. DFS atau DFT adalah algoritma pencarian rekursif yang digunakan untuk menjelajahi semua node dalam suatu graph atau pohon.
</p>

<p align="justify">
<b>Algoritma DFS</b> <br>
Implementasi dasar dari DFS membagi setiap node dalam graph atau pohon menjadi dua kategori:

<li>Visited (Telah Dikunjungi)</li>
<li>Not Visited (Belum Dikunjungi)</li>
Tujuan dari algoritma ini adalah menandai setiap node yang telah dikunjungi sambil menghindari node yang sudah dikunjungi sebelumnya.
</p>

<p align="justify">
<b>Cara Kerja Algoritma DFS</b><br>
<li>Mulai dengan meletakkan salah satu node dari graph ke dalam sebuah stack.</li>
<li>Ambil node teratas dari stack dan tambahkan ke dalam daftar node yang telah dikunjungi.</li>
<li>Buat daftar node yang berhubungan langsung dengan node tersebut. Tambahkan node yang belum dikunjungi ke dalam stack.</li>
<li>Ulangi langkah 2 dan 3 hingga stack kosong.</li>
</p>
